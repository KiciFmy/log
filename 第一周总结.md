##gulp
* 是一个构建系统，他含有大量的插件，并且我们可以自己编写任务，去自动处理我们自己的项目，比如编译预处理CSS，压缩JavaScript和刷新浏览器，来改进网站开发的过程。
* 所有任务和函数都写在gulpfile.js中
##vagrant
* 统一开发环境，一次配置一次打包，统一分发给团队成员
* 启动虚拟机  在工作目录下

		vagrant up 

* 这样在本地工作目录下所做的修改会同步到虚拟机中，然后启动浏览器访问虚拟机中的项目
##LESS
* 在css的语法上引入了变量，Mixin(混入)，运算以及函数等功能，简化了css的编写，并且降低了CSS的维护成本
* 他包含了一套自定义的语法及解析器，用户可以根据这些语法定义自己的样式规则，这些规则最终会通过解析器编译生成对应的CSS文件，在原有CSS的语法基础上，为CSS加入程序式语言
##github
* Git是用C语言开发的分布版本控制系统。版本控制系统可以保留一个文件集合的历史记录，并能回滚文件集合到另一个状态（历史记录状态）。另一个状态可以是不同的文件，也可以是不同的文件内容。举个例子，你可以将文件集合转换到两天之前的状态，或者你可以在生产代码和实验性质的代码之间进行切换。文件集合往往被称作是“源代码”。在一个分布版本控制系统中，每个人都有一份完整的源代码（包括源代码所有的历史记录信息），而且可以对这个本地的数据进行操作。分布版本控制系统不需要一个集中式的代码仓库。

* 当你对本地的源代码进行了修改，你可以标注他们跟下一个版本相关（将他们加到index中），然后提交到仓库中来（commit）。Git保存了所有的版本信息，所以你可以转换你的源代码到任何的历史版本。你可以对本地的仓库进行代码的提交，然后与其他的仓库进行同步。你可以使用Git来进行仓库的克隆（clone）操作，完整的复制一个已有的仓库。仓库的所有者可以通过push操作（推送变更到别处的仓库）或者Pull操作（从别处的仓库拉取变更）来同步变更。
* Git支持分支功能（branch）。如果你想开发一个新的产品功能，你可以建立一个分支，对这个分支的进行修改，而不至于会影响到主支上的代码

##seajs
* 我们希望一个页面按需引入，这个页面需要什么功能就引入什么功能
* Seajs是一个加载器遵循 CMD 规范模块化开发，依赖的自动加载、配置的简洁清晰。


##web前端
* 访问网站的大概过程 浏览器和服务器交流 服务器和数据库交流
* 服务器返回给你的html文件里面，写的是一些代码，浏览器拿到这些代码之后，分析一下给你渲染好页面显示出来
* 有了表示内容和语义的 HTML，规定样式的 CSS，得到的是一个静态的页面，avascript（JS） 来给页面添加一些动态的效果
* 用 JS 向知乎服务器发送一个请求，得到这个小窗口应该显示的数据，放在这个小窗口里（这就是所谓的AJAX，不用刷新就能与服务器进行交互，更新页面的一小部分


##web后端
* 浏览器给服务器发一个请求，服务器不是一看就知道怎么响应的。首先这些请求和响应要有一个通用的写法，也就是要有一个协议，常用的是 HTTP 协议
* HTTP 响应里还包括很多东西，比如 Content-type 表示服务器发过来的文件类型是什么（文本？动画？图片？音频？），这样发过去了人家浏览器好知道怎么展示给用户看。人家服务器怎么知道按协议要写什么东西进去呢，这就是 Web Server 干活的时候了。
* 要让这些形形色色的机器能够通过网络进行交互，我们就需要指明一种协议（比如 HTTP/HTTPS）和一种数据封装格式（比如 HTML/XML），Web Server 提供的 Web Service，指的就是这种协议+格式的交流体系。不过 Web Service 的生态系统和 HTML 的标准不一样，用户可以选择的协议和数据封装格式更多，普通的网站访问用的 HTTP + HTML 只是其中一种，一些封闭系统内的交流还可以自己定义一个协议和格式来用（比如 QQ）
*  PHP服务器脚本可以对这些不同的状态，生成不同的页面，交给 Web Server 返回给浏览器。


##一个普通网站访问的过程
*  用户操作浏览器访问，浏览器向服务器发出一个 HTTP 请求；
*  服务器接收到 HTTP 请求，Web Server 进行相应的初步处理，使用服务器脚本生成页面；
*  服务器脚本（利用Web Framework）调用本地和客户端传来的数据，生成页面；
*  Web Server 将生成的页面作为 HTTP 响应的 body，根据不同的处理结果生成 HTTP header，发回给客户端；
*  客户端（浏览器）接收到 HTTP 响应，通常第一个请求得到的 HTTP 响应的 body 里是 HTML 代码，于是对 HTML 代码开始解析；
*  解析过程中遇到引用的服务器上的资源（额外的 CSS、JS代码，图片、音视频，附件等），再向 Web Server 发送请求，Web Server 找到对应的文件，发送回来；
*  浏览器解析 HTML 包含的内容，用得到的 CSS 代码进行外观上的进一步渲染，JS 代码也可能会对外观进行一定的处理；
*  用户与页面交互（点击，悬停等等）时，JS 代码对此作出一定的反应，添加特效与动画；
*  交互的过程中可能需要向服务器索取或提交额外的数据（局部的刷新，类似微博的新消息通知），一般不是跳转就是通过 JS 代码（响应某个动作或者定时）向 Web Server 发送请求，Web Server 再用服务器脚本进行处理（生成资源or写入数据之类的），把资源返回给客户端，客户端用得到的资源来实现动态效果或其他改变。
* 这只是小网站里比较常见的模型，大网站为了解决规模问题还会有很多处理，每个环节都会有一些细微的差异，中间还会使用各种各样的工具减轻服务器的压力，提高效率，方便日常维护~


